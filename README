# ğŸ³ CookBook Application

A full-stack web application for intelligent meal planning, recipe management, and nutritional tracking with strong data consistency and automated inventory management.

[![PostgreSQL](https://img.shields.io/badge/PostgreSQL-15-blue)](https://www.postgresql.org/)
[![FastAPI](https://img.shields.io/badge/FastAPI-0.104+-green)](https://fastapi.tiangolo.com/)
[![React](https://img.shields.io/badge/React-18-blue)](https://reactjs.org/)
[![SQLAlchemy](https://img.shields.io/badge/SQLAlchemy-2.0-red)](https://www.sqlalchemy.org/)

---

## ğŸ“‹ Overview

CookBook helps individuals, restaurants, and food vendors manage recipes, plan menus, track inventory, and generate shopping lists while respecting dietary preferences and ingredient expiration dates.

### Key Features (Planned)
- ğŸ“– **Recipe Catalog** - Store and browse recipes with detailed nutritional information
- ğŸ—“ï¸ **Menu Planning** - Schedule meals with automatic portion scaling
- ğŸ›’ **Shopping Lists** - Auto-generate shopping lists from menu plans
- ğŸ¥— **Dietary Filters** - Exclude recipes based on allergies and preferences
- â° **Expiration Tracking** - Get alerts for ingredients nearing expiration
- ğŸ“Š **Nutrition Analysis** - Calculate nutritional values per meal and day

### Current Status: Stage 1 Complete âœ…
**Completed:**
- âœ… PostgreSQL database schema with 7 tables
- âœ… SQLAlchemy 2.0 ORM models with composite keys
- âœ… Automated CSV data seeding
- âœ… Docker Compose development environment

**Next Milestone:** REST API implementation with Pydantic schemas

---

## ğŸ—ï¸ Architecture

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  React Frontend  â”‚ â† Stage 3 (Planned)
â”‚  + TanStack Queryâ”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ REST API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  FastAPI Backend â”‚ â† Stage 2 (In Progress)
â”‚  + SQLAlchemy 2.0â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ ORM
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   PostgreSQL 15  â”‚ â† Stage 1 (Complete)
â”‚    (Docker)      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Technology Stack

**Backend:**
- FastAPI (Python 3.10+)
- SQLAlchemy 2.0 with typed `Mapped` annotations
- Pydantic 2.0 for validation
- psycopg2 database driver
- Alembic for migrations

**Frontend:**
- React 18 + TypeScript
- Vite build tool
- Tanstack Query (React Query) for state management
- Tailwind CSS for styling

**Database:**
- PostgreSQL 15 (Dockerized)
- Composite primary keys for flexible data modeling
- Strong referential integrity with foreign key constraints

---

## ğŸš€ Quick Start

### Prerequisites
- Docker & Docker Compose
- Python 3.10 or higher
- Node.js 18+ (for frontend, optional)

### 1. Clone the Repository
```bash
git clone <repository-url>
cd cookbook-app
```

### 2. Start the Database
```bash
docker compose up -d
```
> **Note:** PostgreSQL runs on port `5433` (host) to avoid conflicts with local installations.

Verify the database is running:
```bash
docker ps
# Should show "cookbook_db" container running
```

### 3. Set Up the Backend
```bash
cd backend
python -m venv venv
source venv/bin/activate  # On Windows: venv\Scripts\activate
pip install -r requirements.txt
```

### 4. Initialize the Database
This command drops existing tables, recreates the schema, and loads data from CSV files:
```bash
python -m app.seed
```

**Expected Output:**
```
Successfully seeded all tables!
```

**Verify Data:**
```bash
docker exec -it cookbook_db psql -U user -d cookbook -c "SELECT COUNT(*) FROM recipes;"
```

### 5. Start the Development Server (Future)
```bash
uvicorn app.main:app --reload
```
API will be available at: `http://localhost:8000`

### 6. Start the Frontend (Future)
```bash
cd frontend
npm install
npm run dev
```
App will be available at: `http://localhost:5173`

---

## ğŸ“Š Database Schema

### Tables Overview

| Table          | Records | Purpose                                    |
|----------------|---------|-------------------------------------------|
| `nutrients`    | ~100    | Nutritional values per ingredient group   |
| `ingredients`  | ~200    | Ingredient catalog with unit variations   |
| `recipes`      | ~50     | Recipe metadata and serving sizes         |
| `mise_en_place`| ~500    | Recipe instructions (ingredient tuples)   |
| `diets`        | ~20     | Dietary restriction mappings              |
| `preferences`  | ~30     | User ingredient exclusions                |
| `menu_plan`    | ~100    | Scheduled meals with portions             |

### Key Relationships

```mermaid
erDiagram
    NUTRIENTS ||--o{ INGREDIENTS : "groups"
    INGREDIENTS ||--o{ MISE_EN_PLACE : "uses"
    RECIPES ||--o{ MISE_EN_PLACE : "contains"
    RECIPES ||--o{ MENU_PLAN : "scheduled in"
    DIETS ||--o{ PREFERENCES : "defines"
    INGREDIENTS }o--|| PREFERENCES : "excluded by"
```

### Notable Design Decisions

**Composite Primary Keys:**
- `ingredients(name, unit_default)` - Same ingredient in different units (e.g., "Kiwi" in pieces, ml, g)
- `mise_en_place(recipe_name, ingredient_name, unit)` - Recipe can use same ingredient multiple times

**Weak Foreign Key:**
- `preferences.article` â†’ `ingredients.name` enforced by application logic, not database
- **Rationale:** Dietary preferences apply to all unit variations of an ingredient
- **Trade-off:** Flexibility vs. strict referential integrity

---

## ğŸ“ Project Structure

```
cookbook-app/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ app/
â”‚   â”‚   â”œâ”€â”€ database.py          # SQLAlchemy configuration
â”‚   â”‚   â”œâ”€â”€ models.py            # ORM models (Stage 1 âœ…)
â”‚   â”‚   â”œâ”€â”€ seed.py              # CSV data loader (Stage 1 âœ…)
â”‚   â”‚   â”œâ”€â”€ main.py              # FastAPI app (Stage 2 ğŸ”„)
â”‚   â”‚   â”œâ”€â”€ schemas.py           # Pydantic schemas (Stage 2 ğŸ“)
â”‚   â”‚   â””â”€â”€ routers/             # API endpoints (Stage 2 ğŸ“)
â”‚   â”œâ”€â”€ data/                    # CSV seed files
â”‚   â”‚   â”œâ”€â”€ nutrients.csv
â”‚   â”‚   â”œâ”€â”€ ingredients.csv
â”‚   â”‚   â”œâ”€â”€ recipes.csv
â”‚   â”‚   â”œâ”€â”€ instructions.csv
â”‚   â”‚   â”œâ”€â”€ diets.csv
â”‚   â”‚   â”œâ”€â”€ preferences.csv
â”‚   â”‚   â””â”€â”€ menu_plan.csv
â”‚   â”œâ”€â”€ migrations/              # Alembic migrations
â”‚   â”œâ”€â”€ requirements.txt
â”‚   â””â”€â”€ alembic.ini
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ components/          # React components (Stage 3 ğŸ“)
â”‚   â”‚   â”œâ”€â”€ hooks/               # Custom hooks (Stage 3 ğŸ“)
â”‚   â”‚   â””â”€â”€ services/            # API clients (Stage 3 ğŸ“)
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ vite.config.ts
â”œâ”€â”€ docker-compose.yml           # PostgreSQL container
â”œâ”€â”€ README.md
â””â”€â”€ TECHNICAL_SPEC.md            # Detailed technical documentation
```

**Legend:**
- âœ… Complete
- ğŸ”„ In Progress
- ğŸ“ Planned

---

## ğŸ›£ï¸ Development Roadmap

### âœ… Stage 1: Foundation (Complete)
**Duration:** 2 weeks

**Deliverables:**
- [x] PostgreSQL 15 Docker setup with volume persistence
- [x] SQLAlchemy 2.0 models with composite keys and relationships
- [x] CSV seed script loading 7 tables with ~1000 total records
- [x] Git repository structure

**Key Achievement:** Fully functional relational database with sample data.

---

### ğŸ”„ Stage 2: API & Pydantic Layer (In Progress)
**Duration:** 2-3 weeks  
**Start Date:** Current

#### Tasks
1. **Create Pydantic Schemas** (Week 1)
   - [ ] Define request/response models for all entities
   - [ ] Prevent circular references in Recipe â†” MiseEnPlace
   - [ ] Add validation rules (positive quantities, non-empty strings)

2. **Implement Core Endpoints** (Week 1-2)
   - [ ] `GET /recipes` - List recipes with pagination
   - [ ] `GET /recipes/{name}` - Get recipe with ingredients (joined load)
   - [ ] `GET /ingredients` - List ingredients with filtering
   - [ ] `GET /nutrients/{group}` - Get nutritional info

3. **Database Session Management** (Week 2)
   - [ ] Create FastAPI dependency for session injection
   - [ ] Implement automatic session cleanup
   - [ ] Add error handling for database exceptions

4. **Testing** (Week 2-3)
   - [ ] Write pytest tests for endpoints
   - [ ] Test composite key constraints
   - [ ] Validate Pydantic schema serialization

#### Example Endpoint Implementation
```python
# app/routers/recipes.py
from fastapi import APIRouter, Depends, HTTPException
from sqlalchemy.orm import Session, joinedload
from ..schemas import RecipeResponse
from ..models import Recipe
from ..database import get_db

router = APIRouter(prefix="/recipes", tags=["recipes"])

@router.get("/{name}", response_model=RecipeResponse)
async def get_recipe(name: str, db: Session = Depends(get_db)):
    recipe = db.query(Recipe)\
        .options(joinedload(Recipe.ingredients_list))\
        .filter(Recipe.name == name)\
        .first()
    
    if not recipe:
        raise HTTPException(status_code=404, detail="Recipe not found")
    
    return recipe
```

#### Acceptance Criteria
- âœ… All endpoints return valid JSON without circular references
- âœ… P95 latency < 200ms for simple queries, < 500ms for complex joins
- âœ… 100% endpoint test coverage
- âœ… API documentation auto-generated at `/docs`

---

### ğŸ“± Stage 3: Frontend Foundation
**Duration:** 3 weeks  
**Prerequisites:** Stage 2 complete

#### Tasks
1. **Setup** (Week 1)
   - [ ] Configure Tanstack Query client
   - [ ] Set up Axios with base URL
   - [ ] Create reusable API hooks

2. **Components** (Week 1-2)
   - [ ] `RecipeTable` - Paginated recipe list with Tailwind
   - [ ] `RecipeModal` - Show ingredients and instructions
   - [ ] `Navbar` - Navigate between Recipes/Ingredients/Menu Plan
   - [ ] `SearchBar` - Filter recipes client-side

3. **State Management** (Week 2)
   - [ ] Implement Tanstack Query for recipe fetching
   - [ ] Add loading/error states
   - [ ] Implement optimistic updates for menu planning

4. **Styling** (Week 3)
   - [ ] Mobile-responsive design
   - [ ] Dark mode support
   - [ ] Accessibility (ARIA labels, keyboard navigation)

#### Example Component
```tsx
// src/components/RecipeTable.tsx
import { useQuery } from '@tanstack/react-query';
import { getRecipes } from '../services/api';

export function RecipeTable() {
  const { data, isLoading, error } = useQuery({
    queryKey: ['recipes'],
    queryFn: getRecipes
  });

  if (isLoading) return <LoadingSpinner />;
  if (error) return <ErrorMessage error={error} />;

  return (
    <table className="min-w-full divide-y divide-gray-200">
      {/* Table implementation */}
    </table>
  );
}
```

#### Acceptance Criteria
- âœ… Users can browse and search recipes
- âœ… Modal displays full recipe details on click
- âœ… App is mobile-responsive
- âœ… No layout shifts during loading

---

### ğŸ§® Stage 4: Business Logic Implementation
**Duration:** 4 weeks  
**Prerequisites:** Stage 3 complete

#### Key Features

**1. Menu Planning with Dietary Filters**
```python
# app/services/menu_planner.py
def get_compatible_recipes(user_preferences: list[str]) -> list[Recipe]:
    """Find recipes excluding ingredients with problematic components."""
    excluded_ingredients = db.query(Ingredient.name)\
        .join(Preference)\
        .filter(Preference.problematic_component.in_(user_preferences))\
        .all()
    
    return db.query(Recipe)\
        .filter(~Recipe.ingredients_list.any(
            MiseEnPlace.ingredient_name.in_(excluded_ingredients)
        ))\
        .all()
```

**2. Shopping List Generation**
```python
# app/services/shopping_list.py
def generate_shopping_list(start_date: date, end_date: date) -> dict:
    """Aggregate ingredients needed for menu plan in date range."""
    return db.query(
        MiseEnPlace.ingredient_name,
        MiseEnPlace.unit,
        func.sum(MiseEnPlace.quantity * MenuPlan.portions).label("total")
    )\
        .join(MenuPlan, MiseEnPlace.recipe_name == MenuPlan.meal)\
        .filter(MenuPlan.date.between(start_date, end_date))\
        .group_by(MiseEnPlace.ingredient_name, MiseEnPlace.unit)\
        .all()
```

**3. Nutritional Calculator**
```python
# app/services/nutrition.py
def calculate_meal_nutrition(recipe_name: str) -> dict:
    """Calculate total nutritional values for a recipe."""
    recipe = db.query(Recipe)\
        .options(joinedload(Recipe.ingredients_list))\
        .filter(Recipe.name == recipe_name)\
        .first()
    
    total = defaultdict(float)
    for ingredient in recipe.ingredients_list:
        nutrients = ingredient.ingredient.nutrient_info
        factor = ingredient.quantity / 100  # Nutrients per 100g
        
        for field in ['kcal', 'proteines', 'graisses', ...]:
            total[field] += getattr(nutrients, field) * factor
    
    return {k: v / recipe.portions for k, v in total.items()}
```

**4. Expiration Alerts** (Requires `on_stock` table)
```python
# app/services/inventory.py
def get_expiring_ingredients(days: int = 3) -> list:
    """Get ingredients expiring within N days not in menu plan."""
    return db.query(OnStock)\
        .filter(
            OnStock.expiration_date.between(
                date.today(), 
                date.today() + timedelta(days=days)
            )
        )\
        .filter(~OnStock.is_reserved_in_menu_plan())\
        .all()
```

#### New Endpoints
- `GET /menu-plan/compatible?preferences=Lactose,Gluten`
- `GET /shopping-list?start=2023-06-25&end=2023-06-30`
- `GET /nutrition/recipe/{name}`
- `GET /nutrition/day/{date}`
- `GET /inventory/expiring?days=3`

#### Acceptance Criteria
- âœ… Dietary filters correctly exclude incompatible recipes
- âœ… Shopping lists aggregate quantities correctly
- âœ… Nutritional values accurate to Â±5%
- âœ… Expiration alerts trigger at correct times

---

### ğŸ³ Stage 5: Production Deployment
**Duration:** 2 weeks  
**Prerequisites:** Stage 4 complete

#### Tasks

**1. Dockerize Backend**
```dockerfile
# backend/Dockerfile
FROM python:3.10-slim
WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY . .
CMD ["uvicorn", "app.main:app", "--host", "0.0.0.0", "--port", "8000"]
```

**2. Dockerize Frontend**
```dockerfile
# frontend/Dockerfile
# Build stage
FROM node:18 AS build
WORKDIR /app
COPY package*.json ./
RUN npm ci
COPY . .
RUN npm run build

# Production stage
FROM nginx:alpine
COPY --from=build /app/dist /usr/share/nginx/html
COPY nginx.conf /etc/nginx/conf.d/default.conf
```

**3. Nginx Configuration**
```nginx
# frontend/nginx.conf
server {
    listen 80;
    root /usr/share/nginx/html;
    
    location / {
        try_files $uri $uri/ /index.html;
    }
    
    location /api {
        proxy_pass http://backend:8000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

**4. Production Docker Compose**
```yaml
# docker-compose.prod.yml
services:
  db:
    image: postgres:15
    environment:
      POSTGRES_USER: ${DB_USER}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
      POSTGRES_DB: cookbook
    volumes:
      - postgres_data:/var/lib/postgresql/data

  backend:
    build: ./backend
    environment:
      DATABASE_URL: postgresql://${DB_USER}:${DB_PASSWORD}@db:5432/cookbook
    depends_on:
      - db

  frontend:
    build: ./frontend
    ports:
      - "80:80"
    depends_on:
      - backend
```

**5. CI/CD Pipeline** (GitHub Actions)
```yaml
# .github/workflows/deploy.yml
name: Deploy to Cloud Run
on:
  push:
    branches: [main]
jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build and push Docker images
        # ... build steps
      - name: Deploy to Cloud Run
        # ... deployment steps
```

#### Deployment Options
- **Google Cloud Run** (Recommended)
  - Automatic scaling
  - Pay-per-use pricing
  - Managed SSL certificates

- **Firebase Hosting + Cloud Run**
  - Static frontend on Firebase CDN
  - Backend on Cloud Run
  - Integrated authentication

- **DigitalOcean App Platform**
  - Simple deployment from GitHub
  - Managed database option
  - Built-in monitoring

#### Acceptance Criteria
- âœ… App accessible via public URL with SSL
- âœ… Database migrations automated
- âœ… Environment variables managed securely
- âœ… CI/CD pipeline deploys on push to main
- âœ… Health check endpoint returns 200

---

## ğŸ” Environment Variables

### Backend `.env`
```bash
# Database
DATABASE_URL=postgresql://user:password@localhost:5433/cookbook

# Security
SECRET_KEY=your-secret-key-here
ALGORITHM=HS256
ACCESS_TOKEN_EXPIRE_MINUTES=30

# API
CORS_ORIGINS=http://localhost:5173,http://localhost:3000
```

### Frontend `.env`
```bash
VITE_API_BASE_URL=http://localhost:8000/api
```

> **Important:** Never commit `.env` files to version control. Use `.env.example` as a template.

---

## ğŸ§ª Testing

### Run Backend Tests
```bash
cd backend
pytest tests/ -v
```

### Run Frontend Tests
```bash
cd frontend
npm run test
```

### End-to-End Tests
```bash
npm run test:e2e
```

---

## ğŸ“š Documentation

- **[TECHNICAL_SPEC.md](TECHNICAL_SPEC.md)** - Detailed architecture and design decisions
- **[API Documentation](http://localhost:8000/docs)** - Auto-generated Swagger UI (after Stage 2)
- **[Database Schema](docs/schema.md)** - ER diagrams and table specifications (future)

---

## ğŸ¤ Contributing

### Development Workflow
1. Create a feature branch: `git checkout -b feature/your-feature`
2. Make changes and commit: `git commit -m "Add feature"`
3. Push to branch: `git push origin feature/your-feature`
4. Open a pull request

### Code Standards
- **Backend:** PEP 8 + Black formatter
- **Frontend:** ESLint + Prettier
- **Commits:** Conventional Commits format

---

## ğŸ› Known Issues

1. **No Foreign Key on Preferences Table**
   - `preferences.article` â†’ `ingredients.name` enforced by application logic only
   - Risk: Orphaned preferences if ingredients deleted
   - Mitigation: Validation before insert + periodic cleanup jobs

2. **No Database Migrations**
   - Schema changes require manual seed script re-run
   - Action: Generate initial Alembic migration in Stage 2

3. **Hardcoded Credentials**
   - Database credentials in `docker-compose.yml`
   - Action: Move to `.env` files before production

---

## ğŸ“ License

This project is licensed under the MIT License.

---

## ğŸ“§ Contact

For questions or feedback, please contact the development team or open an issue on GitHub.

---

## ğŸ™ Acknowledgments

- PostgreSQL documentation for composite key examples
- FastAPI community for best practices
- SQLAlchemy 2.0 migration guides

---

**Last Updated:** February 2026  
**Version:** 1.0.0 (Stage 1 Complete)